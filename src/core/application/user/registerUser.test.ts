import { beforeEach, describe, expect, it } from "vitest";
import type { MockEmailService } from "@/core/adapters/mock/emailService";
import {
  createMockContext,
  resetMockContext,
} from "@/core/adapters/mock/testContext";
import type { Context } from "../context";
import { type RegisterUserInput, registerUser } from "./registerUser";

describe("registerUser", () => {
  let context: Context;

  beforeEach(() => {
    context = createMockContext();
    resetMockContext(context);
  });

  describe("successful registration", () => {
    it("should register a new user with valid data", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
        bio: "Test bio",
        avatar: "https://example.com/avatar.jpg",
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.email).toBe(input.email);
        expect(result.value.name).toBe(input.name);
        expect(result.value.bio).toBe(input.bio);
        expect(result.value.avatar).toBe(input.avatar);
        expect(result.value.role).toBe("visitor");
        expect(result.value.status).toBe("active");
        expect(result.value.emailVerified).toBe(false);
        expect(result.value.id).toBeDefined();
        expect(result.value.createdAt).toBeInstanceOf(Date);
        expect(result.value.updatedAt).toBeInstanceOf(Date);
      }
    });

    it("should hash the password", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.hashedPassword).toBe("hashed_password123");
        expect(result.value.hashedPassword).not.toBe(input.password);
      }
    });

    it("should create default notification settings", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        const settingsResult =
          await context.notificationSettingsRepository.findByUserId(
            result.value.id,
          );
        expect(settingsResult.isOk()).toBe(true);
        if (settingsResult.isOk()) {
          expect(settingsResult.value).toBeDefined();
          expect(settingsResult.value!.emailNotifications).toBe(true);
          expect(settingsResult.value!.checkinNotifications).toBe(true);
          expect(settingsResult.value!.editorInviteNotifications).toBe(true);
          expect(settingsResult.value!.systemNotifications).toBe(true);
        }
      }
    });

    it("should send verification and welcome emails", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);

      const emailService = context.emailService as MockEmailService;
      const sentEmails = emailService.getSentEmails();

      expect(sentEmails).toHaveLength(1);
      expect(sentEmails[0].type).toBe("welcome");
      expect(sentEmails[0].to).toBe(input.email);
      expect(sentEmails[0].name).toBe(input.name);
    });

    it("should create email verification token", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        // We can't directly check the token creation since it's async,
        // but we can verify the token was generated by checking the email service was called
        const emailService = context.emailService as MockEmailService;
        const sentEmails = emailService.getSentEmails();
        expect(sentEmails.length).toBeGreaterThan(0);
      }
    });

    it("should register with minimal required fields", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.email).toBe(input.email);
        expect(result.value.name).toBe(input.name);
        expect(result.value.bio).toBeUndefined();
        expect(result.value.avatar).toBeUndefined();
      }
    });
  });

  describe("registration failures", () => {
    it("should fail when email is already taken", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
      };

      // Register the first user
      const firstResult = await registerUser(context, input);
      expect(firstResult.isOk()).toBe(true);

      // Try to register with the same email
      const secondResult = await registerUser(context, input);
      expect(secondResult.isErr()).toBe(true);
      if (secondResult.isErr()) {
        expect(secondResult.error.message).toBe("Email is already in use");
      }
    });

    it("should fail when transaction fails", async () => {
      context = createMockContext({ shouldFailTransaction: true });

      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
      };

      const result = await registerUser(context, input);

      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.message).toBe(
          "Transaction failed during user registration",
        );
      }
    });

    it("should still succeed even if email sending fails", async () => {
      context = createMockContext({ shouldFailEmail: true });

      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
      };

      const result = await registerUser(context, input);

      // Registration should succeed even if email fails
      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.email).toBe(input.email);
      }
    });
  });

  describe("input validation edge cases", () => {
    it("should handle minimum length password", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "12345678", // Minimum 8 characters
        name: "Test User",
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.email).toBe(input.email);
      }
    });

    it("should handle maximum length password", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "a".repeat(128), // Maximum 128 characters
        name: "Test User",
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.email).toBe(input.email);
      }
    });

    it("should handle minimum length name", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "A", // Minimum 1 character
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.name).toBe(input.name);
      }
    });

    it("should handle maximum length name", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "A".repeat(100), // Maximum 100 characters
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.name).toBe(input.name);
      }
    });

    it("should handle maximum length bio", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
        bio: "A".repeat(500), // Maximum 500 characters
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.bio).toBe(input.bio);
      }
    });

    it("should handle special characters in email", async () => {
      const input: RegisterUserInput = {
        email: "test+special.email-123@example.com",
        password: "password123",
        name: "Test User",
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.email).toBe(input.email);
      }
    });

    it("should handle unicode characters in name", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "テストユーザー",
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.name).toBe(input.name);
      }
    });

    it("should handle valid avatar URL", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
        avatar: "https://secure.example.com/path/to/avatar.jpg?v=123",
      };

      const result = await registerUser(context, input);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.avatar).toBe(input.avatar);
      }
    });
  });

  describe("concurrency", () => {
    it("should handle concurrent registrations with different emails", async () => {
      const inputs = [
        {
          email: "user1@example.com",
          password: "password123",
          name: "User 1",
        },
        {
          email: "user2@example.com",
          password: "password123",
          name: "User 2",
        },
        {
          email: "user3@example.com",
          password: "password123",
          name: "User 3",
        },
      ];

      const results = await Promise.all(
        inputs.map((input) => registerUser(context, input)),
      );

      for (const result of results) {
        expect(result.isOk()).toBe(true);
      }

      // Verify all users have unique IDs
      const userIds = results.map((r) => (r.isOk() ? r.value.id : ""));
      const uniqueIds = new Set(userIds);
      expect(uniqueIds.size).toBe(inputs.length);
    });

    it("should handle concurrent registrations with the same email", async () => {
      const input: RegisterUserInput = {
        email: "test@example.com",
        password: "password123",
        name: "Test User",
      };

      const results = await Promise.all([
        registerUser(context, input),
        registerUser(context, input),
        registerUser(context, input),
      ]);

      // Only one should succeed, others should fail with email taken error
      const successfulResults = results.filter((r) => r.isOk());
      const failedResults = results.filter((r) => r.isErr());

      expect(successfulResults).toHaveLength(1);
      expect(failedResults).toHaveLength(2);

      for (const failedResult of failedResults) {
        if (failedResult.isErr()) {
          expect(failedResult.error.message).toBe("Email is already in use");
        }
      }
    });
  });
});
